{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionEnvelope = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n/**\n * Contains a Transaction that is being built.\n */\n\n\nvar TransactionEnvelope = /*#__PURE__*/function () {\n  function TransactionEnvelope(provider, instructions) {\n    var signers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, TransactionEnvelope);\n\n    this.provider = provider;\n    this.instructions = instructions;\n    this.signers = signers;\n  }\n\n  _createClass(TransactionEnvelope, [{\n    key: \"addSigners\",\n    value: function addSigners() {\n      var _this$signers;\n\n      (_this$signers = this.signers).push.apply(_this$signers, arguments);\n\n      return this;\n    }\n    /**\n     * Builds a transaction from this envelope.\n     */\n\n  }, {\n    key: \"build\",\n    value: function build() {\n      var _web3_js_1$Transactio;\n\n      return (_web3_js_1$Transactio = new web3_js_1.Transaction()).add.apply(_web3_js_1$Transactio, _toConsumableArray(this.instructions));\n    }\n    /**\n     * Generates a link for inspecting the contents of this {@link TransactionEnvelope}.\n     *\n     * @returns URL\n     */\n\n  }, {\n    key: \"generateInspectLink\",\n    value: function generateInspectLink() {\n      var cluster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"mainnet-beta\";\n      var t = this.build();\n      t.recentBlockhash = \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"; // Some stub\n\n      t.feePayer = this.provider.wallet.publicKey;\n      var str = t.serializeMessage().toString(\"base64\");\n      return \"https://explorer.solana.com/tx/inspector?cluster=\".concat(cluster, \"&message=\").concat(encodeURIComponent(str));\n    }\n    /**\n     * Simulates the transaction.\n     * @param opts\n     * @returns\n     */\n\n  }, {\n    key: \"simulate\",\n    value: function simulate(opts) {\n      return this.provider.simulate(this.build(), this.signers, opts);\n    }\n    /**\n     * Sends the transaction without confirming it.\n     * @param opts\n     * @returns\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(opts) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var signed;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.provider.signer.sign(this.build(), this.signers, opts);\n\n              case 2:\n                signed = _context.sent;\n                return _context.abrupt(\"return\", this.provider.broadcaster.broadcast(signed, opts));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Sends the transaction and waits for confirmation.\n     * @param opts\n     */\n\n  }, {\n    key: \"confirm\",\n    value: function confirm(opts) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.send(opts);\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent.wait());\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Combines the instructions/signers of the other envelope to create one large transaction.\n     */\n\n  }, {\n    key: \"combine\",\n    value: function combine(other) {\n      return new TransactionEnvelope(this.provider, [].concat(_toConsumableArray(this.instructions), _toConsumableArray(other.instructions)), [].concat(_toConsumableArray(this.signers), _toConsumableArray(other.signers)));\n    }\n    /**\n     * Get a list of all writable accounts, deduped\n     * All of these accounts likely need to be updated after the transaction is confirmed.\n     */\n\n  }, {\n    key: \"writableKeys\",\n    get: function get() {\n      return _toConsumableArray(new Set(_toConsumableArray(this.instructions.map(function (inst) {\n        return inst.keys.filter(function (key) {\n          return key.isWritable;\n        }).map(function (k) {\n          return k.pubkey;\n        });\n      }).reduce(function (acc, el) {\n        return acc.concat(el);\n      }))).values());\n    }\n    /**\n     * Gets the instructions in a format that can be serialized easily to JSON.\n     */\n\n  }, {\n    key: \"instructionsJSON\",\n    get: function get() {\n      return this.instructions.map(function (instruction) {\n        return {\n          programId: instruction.programId.toString(),\n          keys: instruction.keys.map(function (m) {\n            return {\n              isSigner: m.isSigner,\n              isWritable: m.isWritable,\n              publicKey: m.pubkey.toString()\n            };\n          }),\n          data: instruction.data.toString(\"base64\")\n        };\n      });\n    }\n    /**\n     * Returns a string representation of the {@link TransactionEnvelope}.\n     */\n\n  }, {\n    key: \"debugStr\",\n    get: function get() {\n      return [\"=> Instructions\", this.instructions.map(function (ser, i) {\n        return [\"Instruction \".concat(i, \": \").concat(ser.programId.toString())].concat(_toConsumableArray(ser.keys.map(function (k, i) {\n          return \"  [\".concat(i, \"] \").concat(k.pubkey.toString(), \" \").concat(k.isWritable ? \"(mut)\" : \"\", \" \").concat(k.isSigner ? \"(signer)\" : \"\");\n        })), [\"  Data (base64): \".concat(ser.data.toString(\"base64\"))]).join(\"\\n\");\n      }).join(\"\\n\"), \"=> Signers\", this.signers.map(function (sg) {\n        return sg.publicKey.toString();\n      }).join(\"\\n\")].join(\"\\n\");\n    }\n    /**\n     * Combines multiple TransactionEnvelopes into one.\n     */\n\n  }], [{\n    key: \"combineAll\",\n    value: function combineAll() {\n      for (var _len = arguments.length, txs = new Array(_len), _key = 0; _key < _len; _key++) {\n        txs[_key] = arguments[_key];\n      }\n\n      return txs.reduce(function (acc, tx) {\n        return acc.combine(tx);\n      });\n    }\n    /**\n     * Combines multiple async TransactionEnvelopes into one, serially.\n     */\n\n  }, {\n    key: \"combineAllAsync\",\n    value: function combineAllAsync(firstTX) {\n      for (var _len2 = arguments.length, txs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        txs[_key2 - 1] = arguments[_key2];\n      }\n\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var acc, _iterator, _step, tx;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return firstTX;\n\n              case 2:\n                acc = _context3.sent;\n                _iterator = _createForOfIteratorHelper(txs);\n                _context3.prev = 4;\n\n                _iterator.s();\n\n              case 6:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                tx = _step.value;\n                _context3.t0 = acc;\n                _context3.next = 11;\n                return tx;\n\n              case 11:\n                _context3.t1 = _context3.sent;\n                acc = _context3.t0.combine.call(_context3.t0, _context3.t1);\n\n              case 13:\n                _context3.next = 6;\n                break;\n\n              case 15:\n                _context3.next = 20;\n                break;\n\n              case 17:\n                _context3.prev = 17;\n                _context3.t2 = _context3[\"catch\"](4);\n\n                _iterator.e(_context3.t2);\n\n              case 20:\n                _context3.prev = 20;\n\n                _iterator.f();\n\n                return _context3.finish(20);\n\n              case 23:\n                return _context3.abrupt(\"return\", acc);\n\n              case 24:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[4, 17, 20, 23]]);\n      }));\n    }\n    /**\n     * Sends all of the envelopes.\n     * @returns Pending transactions\n     */\n\n  }, {\n    key: \"sendAll\",\n    value: function sendAll(txs, opts) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var firstTX, provider;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                firstTX = txs[0];\n\n                if (firstTX) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", []);\n\n              case 3:\n                provider = firstTX.provider;\n                _context4.next = 6;\n                return provider.sendAll(txs.map(function (tx) {\n                  return {\n                    tx: tx.build(),\n                    signers: tx.signers\n                  };\n                }), opts);\n\n              case 6:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n\n  return TransactionEnvelope;\n}();\n\nexports.TransactionEnvelope = TransactionEnvelope;","map":{"version":3,"sources":["../../src/transaction/TransactionEnvelope.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionEnvelope = void 0;\nconst tslib_1 = require(\"tslib\");\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * Contains a Transaction that is being built.\n */\nclass TransactionEnvelope {\n    constructor(provider, instructions, signers = []) {\n        this.provider = provider;\n        this.instructions = instructions;\n        this.signers = signers;\n    }\n    addSigners(...signers) {\n        this.signers.push(...signers);\n        return this;\n    }\n    /**\n     * Builds a transaction from this envelope.\n     */\n    build() {\n        return new web3_js_1.Transaction().add(...this.instructions);\n    }\n    /**\n     * Generates a link for inspecting the contents of this {@link TransactionEnvelope}.\n     *\n     * @returns URL\n     */\n    generateInspectLink(cluster = \"mainnet-beta\") {\n        const t = this.build();\n        t.recentBlockhash = \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"; // Some stub\n        t.feePayer = this.provider.wallet.publicKey;\n        const str = t.serializeMessage().toString(\"base64\");\n        return `https://explorer.solana.com/tx/inspector?cluster=${cluster}&message=${encodeURIComponent(str)}`;\n    }\n    /**\n     * Simulates the transaction.\n     * @param opts\n     * @returns\n     */\n    simulate(opts) {\n        return this.provider.simulate(this.build(), this.signers, opts);\n    }\n    /**\n     * Sends the transaction without confirming it.\n     * @param opts\n     * @returns\n     */\n    send(opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const signed = yield this.provider.signer.sign(this.build(), this.signers, opts);\n            return this.provider.broadcaster.broadcast(signed, opts);\n        });\n    }\n    /**\n     * Sends the transaction and waits for confirmation.\n     * @param opts\n     */\n    confirm(opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            return (yield this.send(opts)).wait();\n        });\n    }\n    /**\n     * Combines the instructions/signers of the other envelope to create one large transaction.\n     */\n    combine(other) {\n        return new TransactionEnvelope(this.provider, [...this.instructions, ...other.instructions], [...this.signers, ...other.signers]);\n    }\n    /**\n     * Get a list of all writable accounts, deduped\n     * All of these accounts likely need to be updated after the transaction is confirmed.\n     */\n    get writableKeys() {\n        return [\n            ...new Set([\n                ...this.instructions\n                    .map((inst) => inst.keys.filter((key) => key.isWritable).map((k) => k.pubkey))\n                    .reduce((acc, el) => acc.concat(el)),\n            ]).values(),\n        ];\n    }\n    /**\n     * Gets the instructions in a format that can be serialized easily to JSON.\n     */\n    get instructionsJSON() {\n        return this.instructions.map((instruction) => ({\n            programId: instruction.programId.toString(),\n            keys: instruction.keys.map((m) => ({\n                isSigner: m.isSigner,\n                isWritable: m.isWritable,\n                publicKey: m.pubkey.toString(),\n            })),\n            data: instruction.data.toString(\"base64\"),\n        }));\n    }\n    /**\n     * Returns a string representation of the {@link TransactionEnvelope}.\n     */\n    get debugStr() {\n        return [\n            \"=> Instructions\",\n            this.instructions\n                .map((ser, i) => {\n                return [\n                    `Instruction ${i}: ${ser.programId.toString()}`,\n                    ...ser.keys.map((k, i) => `  [${i}] ${k.pubkey.toString()} ${k.isWritable ? \"(mut)\" : \"\"} ${k.isSigner ? \"(signer)\" : \"\"}`),\n                    `  Data (base64): ${ser.data.toString(\"base64\")}`,\n                ].join(\"\\n\");\n            })\n                .join(\"\\n\"),\n            \"=> Signers\",\n            this.signers.map((sg) => sg.publicKey.toString()).join(\"\\n\"),\n        ].join(\"\\n\");\n    }\n    /**\n     * Combines multiple TransactionEnvelopes into one.\n     */\n    static combineAll(...txs) {\n        return txs.reduce((acc, tx) => acc.combine(tx));\n    }\n    /**\n     * Combines multiple async TransactionEnvelopes into one, serially.\n     */\n    static combineAllAsync(firstTX, ...txs) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            let acc = yield firstTX;\n            for (const tx of txs) {\n                acc = acc.combine(yield tx);\n            }\n            return acc;\n        });\n    }\n    /**\n     * Sends all of the envelopes.\n     * @returns Pending transactions\n     */\n    static sendAll(txs, opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const firstTX = txs[0];\n            if (!firstTX) {\n                return [];\n            }\n            const provider = firstTX.provider;\n            return yield provider.sendAll(txs.map((tx) => ({ tx: tx.build(), signers: tx.signers })), opts);\n        });\n    }\n}\nexports.TransactionEnvelope = TransactionEnvelope;\n//# sourceMappingURL=TransactionEnvelope.js.map"]},"metadata":{},"sourceType":"script"}
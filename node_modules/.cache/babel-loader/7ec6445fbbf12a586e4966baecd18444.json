{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SolanaProvider = exports.SolanaTransactionSigner = exports.SolanaReadonlyProvider = exports.DEFAULT_PROVIDER_OPTIONS = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst broadcaster_1 = require(\"./broadcaster\");\n\nexports.DEFAULT_PROVIDER_OPTIONS = {\n  preflightCommitment: \"recent\",\n  commitment: \"recent\"\n};\n/**\n * Provider that can only read.\n */\n\nclass SolanaReadonlyProvider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param sendConnection The connection where transactions are sent to.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(connection, opts = exports.DEFAULT_PROVIDER_OPTIONS) {\n    this.connection = connection;\n    this.opts = opts;\n  }\n  /**\n   * Gets\n   * @param accountId\n   * @returns\n   */\n\n\n  getAccountInfo(accountId) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const accountInfo = yield this.connection.getAccountInfo(accountId, this.opts.commitment);\n\n      if (!accountInfo) {\n        return null;\n      }\n\n      return {\n        accountId,\n        accountInfo\n      };\n    });\n  }\n\n}\n\nexports.SolanaReadonlyProvider = SolanaReadonlyProvider;\n/**\n * Signs Solana transactions.\n */\n\nclass SolanaTransactionSigner {\n  constructor(wallet, broadcaster, preflightCommitment = \"recent\") {\n    this.wallet = wallet;\n    this.broadcaster = broadcaster;\n    this.preflightCommitment = preflightCommitment;\n  }\n\n  get publicKey() {\n    return this.wallet.publicKey;\n  }\n  /**\n   * Sends the given transaction, paid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n\n\n  sign(tx, signers = [], opts = {\n    preflightCommitment: this.preflightCommitment\n  }) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      tx.feePayer = this.wallet.publicKey;\n      tx.recentBlockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n      yield this.wallet.signTransaction(tx);\n      signers.filter(s => s !== undefined).forEach(kp => {\n        tx.partialSign(kp);\n      });\n      return tx;\n    });\n  }\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n\n\n  signAll(reqs, opts = {\n    preflightCommitment: this.preflightCommitment\n  }) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const blockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n      const txs = reqs.map(r => {\n        const tx = r.tx;\n        let signers = r.signers;\n\n        if (signers === undefined) {\n          signers = [];\n        }\n\n        tx.feePayer = this.wallet.publicKey;\n        tx.recentBlockhash = blockhash;\n        signers.filter(s => s !== undefined).forEach(kp => {\n          tx.partialSign(kp);\n        });\n        return tx;\n      });\n      const signedTxs = yield this.wallet.signAllTransactions(txs);\n      return signedTxs;\n    });\n  }\n\n}\n\nexports.SolanaTransactionSigner = SolanaTransactionSigner;\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n *\n * This implementation was taken from Anchor.\n */\n\nclass SolanaProvider extends SolanaReadonlyProvider {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param sendConnection The connection where transactions are sent to.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  constructor(connection, broadcaster, wallet, opts = exports.DEFAULT_PROVIDER_OPTIONS) {\n    super(connection, opts);\n    this.connection = connection;\n    this.broadcaster = broadcaster;\n    this.wallet = wallet;\n    this.opts = opts;\n    this.signer = new SolanaTransactionSigner(wallet, broadcaster, opts.preflightCommitment);\n  }\n  /**\n   * Creates a new SolanaProvider.\n   */\n\n\n  static load({\n    connection,\n    sendConnection = connection,\n    wallet,\n    opts\n  }) {\n    return new SolanaProvider(connection, new broadcaster_1.SingleConnectionBroadcaster(sendConnection, opts), wallet, opts);\n  }\n  /**\n   * Sends the given transaction, paid for and signed by the provider's wallet.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n\n\n  send(tx, signers = [], opts = this.opts) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const theTx = yield this.signer.sign(tx, signers, opts);\n      const pending = yield this.broadcaster.broadcast(theTx, opts);\n      yield pending.wait();\n      return pending;\n    });\n  }\n  /**\n   * Similar to `send`, but for an array of transactions and signers.\n   */\n\n\n  sendAll(reqs, opts = this.opts) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const txs = yield this.signer.signAll(reqs, opts);\n      return yield Promise.all(txs.map(tx => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const pending = yield this.broadcaster.broadcast(tx, opts);\n        yield pending.wait();\n        return pending;\n      })));\n    });\n  }\n  /**\n   * Simulates the given transaction, returning emitted logs from execution.\n   *\n   * @param tx      The transaction to send.\n   * @param signers The set of signers in addition to the provdier wallet that\n   *                will sign the transaction.\n   * @param opts    Transaction confirmation options.\n   */\n\n\n  simulate(tx, signers = [], opts = this.opts) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const signedTx = yield this.signer.sign(tx, signers, opts);\n      return yield this.broadcaster.simulate(signedTx, opts.commitment);\n    });\n  }\n\n}\n\nexports.SolanaProvider = SolanaProvider;","map":{"version":3,"sources":["../src/provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SolanaProvider = exports.SolanaTransactionSigner = exports.SolanaReadonlyProvider = exports.DEFAULT_PROVIDER_OPTIONS = void 0;\nconst tslib_1 = require(\"tslib\");\nconst broadcaster_1 = require(\"./broadcaster\");\nexports.DEFAULT_PROVIDER_OPTIONS = {\n    preflightCommitment: \"recent\",\n    commitment: \"recent\",\n};\n/**\n * Provider that can only read.\n */\nclass SolanaReadonlyProvider {\n    /**\n     * @param connection The cluster connection where the program is deployed.\n     * @param sendConnection The connection where transactions are sent to.\n     * @param wallet     The wallet used to pay for and sign all transactions.\n     * @param opts       Transaction confirmation options to use by default.\n     */\n    constructor(connection, opts = exports.DEFAULT_PROVIDER_OPTIONS) {\n        this.connection = connection;\n        this.opts = opts;\n    }\n    /**\n     * Gets\n     * @param accountId\n     * @returns\n     */\n    getAccountInfo(accountId) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const accountInfo = yield this.connection.getAccountInfo(accountId, this.opts.commitment);\n            if (!accountInfo) {\n                return null;\n            }\n            return {\n                accountId,\n                accountInfo,\n            };\n        });\n    }\n}\nexports.SolanaReadonlyProvider = SolanaReadonlyProvider;\n/**\n * Signs Solana transactions.\n */\nclass SolanaTransactionSigner {\n    constructor(wallet, broadcaster, preflightCommitment = \"recent\") {\n        this.wallet = wallet;\n        this.broadcaster = broadcaster;\n        this.preflightCommitment = preflightCommitment;\n    }\n    get publicKey() {\n        return this.wallet.publicKey;\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    sign(tx, signers = [], opts = {\n        preflightCommitment: this.preflightCommitment,\n    }) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            tx.feePayer = this.wallet.publicKey;\n            tx.recentBlockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n            yield this.wallet.signTransaction(tx);\n            signers\n                .filter((s) => s !== undefined)\n                .forEach((kp) => {\n                tx.partialSign(kp);\n            });\n            return tx;\n        });\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n    signAll(reqs, opts = {\n        preflightCommitment: this.preflightCommitment,\n    }) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const blockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n            const txs = reqs.map((r) => {\n                const tx = r.tx;\n                let signers = r.signers;\n                if (signers === undefined) {\n                    signers = [];\n                }\n                tx.feePayer = this.wallet.publicKey;\n                tx.recentBlockhash = blockhash;\n                signers\n                    .filter((s) => s !== undefined)\n                    .forEach((kp) => {\n                    tx.partialSign(kp);\n                });\n                return tx;\n            });\n            const signedTxs = yield this.wallet.signAllTransactions(txs);\n            return signedTxs;\n        });\n    }\n}\nexports.SolanaTransactionSigner = SolanaTransactionSigner;\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n *\n * This implementation was taken from Anchor.\n */\nclass SolanaProvider extends SolanaReadonlyProvider {\n    /**\n     * @param connection The cluster connection where the program is deployed.\n     * @param sendConnection The connection where transactions are sent to.\n     * @param wallet     The wallet used to pay for and sign all transactions.\n     * @param opts       Transaction confirmation options to use by default.\n     */\n    constructor(connection, broadcaster, wallet, opts = exports.DEFAULT_PROVIDER_OPTIONS) {\n        super(connection, opts);\n        this.connection = connection;\n        this.broadcaster = broadcaster;\n        this.wallet = wallet;\n        this.opts = opts;\n        this.signer = new SolanaTransactionSigner(wallet, broadcaster, opts.preflightCommitment);\n    }\n    /**\n     * Creates a new SolanaProvider.\n     */\n    static load({ connection, sendConnection = connection, wallet, opts, }) {\n        return new SolanaProvider(connection, new broadcaster_1.SingleConnectionBroadcaster(sendConnection, opts), wallet, opts);\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    send(tx, signers = [], opts = this.opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const theTx = yield this.signer.sign(tx, signers, opts);\n            const pending = yield this.broadcaster.broadcast(theTx, opts);\n            yield pending.wait();\n            return pending;\n        });\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n    sendAll(reqs, opts = this.opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const txs = yield this.signer.signAll(reqs, opts);\n            return yield Promise.all(txs.map((tx) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n                const pending = yield this.broadcaster.broadcast(tx, opts);\n                yield pending.wait();\n                return pending;\n            })));\n        });\n    }\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    simulate(tx, signers = [], opts = this.opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const signedTx = yield this.signer.sign(tx, signers, opts);\n            return yield this.broadcaster.simulate(signedTx, opts.commitment);\n        });\n    }\n}\nexports.SolanaProvider = SolanaProvider;\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PendingTransaction = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst promise_retry_1 = (0, tslib_1.__importDefault)(require(\"promise-retry\"));\n\nconst transaction_1 = require(\"../transaction\");\n/**\n * Transaction which may or may not be confirmed.\n */\n\n\nclass PendingTransaction {\n  constructor(connection, signature) {\n    this.connection = connection;\n    this.signature = signature;\n    this._receipt = null;\n  }\n  /**\n   * Gets the transaction receipt, if it has already been fetched.\n   *\n   * You probably want the async version of this function, `wait`.\n   */\n\n\n  get receipt() {\n    return this._receipt;\n  }\n  /**\n   * Waits for the confirmation of the transaction, via polling.\n   * @returns\n   */\n\n\n  wait(_a = {\n    commitment: \"confirmed\"\n  }) {\n    var {\n      commitment = \"confirmed\"\n    } = _a,\n        retryOpts = (0, tslib_1.__rest)(_a, [\"commitment\"]);\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (this._receipt) {\n        return this._receipt;\n      }\n\n      const receipt = yield (0, promise_retry_1.default)(retry => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n        const result = yield this.connection.getTransaction(this.signature, {\n          commitment\n        });\n\n        if (!result) {\n          retry(new Error(\"Error fetching transaction\"));\n          return;\n        }\n\n        return new transaction_1.TransactionReceipt(this.signature, result);\n      }), Object.assign({\n        retries: 5,\n        minTimeout: 500\n      }, retryOpts));\n\n      if (!receipt) {\n        throw new Error(\"transaction could not be confirmed\");\n      }\n\n      this._receipt = receipt;\n      return receipt;\n    });\n  }\n\n}\n\nexports.PendingTransaction = PendingTransaction;","map":{"version":3,"sources":["../../src/transaction/PendingTransaction.ts"],"names":[],"mappings":";;;;;;;;;AAKA,MAAA,eAAA,GAAA,CAAA,GAAA,OAAA,CAAA,eAAA,EAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AAGA,MAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAEA;;AAEG;;;AACH,MAAa,kBAAb,CAA+B;AAG7B,EAAA,WAAA,CACkB,UADlB,EAEkB,SAFlB,EAEiD;AAD/B,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,SAAA,GAAA,SAAA;AAJV,SAAA,QAAA,GAAsC,IAAtC;AAKJ;AAEJ;;;;AAIG;;;AACQ,MAAP,OAAO,GAAA;AACT,WAAO,KAAK,QAAZ;AACD;AAED;;;AAGG;;;AACU,EAAA,IAAI,CACf,EAAA,GAKI;AACF,IAAA,UAAU,EAAE;AADV,GANW,EAQd;QAPD;AACE,MAAA,UAAU,GAAG;AADf,QAC0B,E;QACrB,SAAS,GAAA,CAAA,GAAA,OAAA,CAAA,MAAA,EAAA,EAAA,EAFd,CAAA,YAAA,CAEc,C;;AAOd,UAAI,KAAK,QAAT,EAAmB;AACjB,eAAO,KAAK,QAAZ;AACD;;AACD,YAAM,OAAO,GAAG,MAAM,CAAA,GAAA,eAAA,CAAA,OAAA,EACb,KAAP,IAAgB,CAAA,GAAA,OAAA,CAAA,SAAA,EAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AACd,cAAM,MAAM,GAAG,MAAM,KAAK,UAAL,CAAgB,cAAhB,CAA+B,KAAK,SAApC,EAA+C;AAClE,UAAA;AADkE,SAA/C,CAArB;;AAGA,YAAI,CAAC,MAAL,EAAa;AACX,UAAA,KAAK,CAAC,IAAI,KAAJ,CAAU,4BAAV,CAAD,CAAL;AACA;AACD;;AACD,eAAO,IAAI,aAAA,CAAA,kBAAJ,CAAuB,KAAK,SAA5B,EAAuC,MAAvC,CAAP;AACD,OATe,CADI,EAUnB,MAAA,CAAA,MAAA,CAAA;AAEC,QAAA,OAAO,EAAE,CAFV;AAGC,QAAA,UAAU,EAAE;AAHb,OAAA,EAII,SAJJ,CAVmB,CAAtB;;AAiBA,UAAI,CAAC,OAAL,EAAc;AACZ,cAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACD;;AACD,WAAK,QAAL,GAAgB,OAAhB;AACA,aAAO,OAAP;;AACD;;AAxD4B;;AAA/B,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PendingTransaction = void 0;\nconst tslib_1 = require(\"tslib\");\nconst promise_retry_1 = (0, tslib_1.__importDefault)(require(\"promise-retry\"));\nconst transaction_1 = require(\"../transaction\");\n/**\n * Transaction which may or may not be confirmed.\n */\nclass PendingTransaction {\n    constructor(connection, signature) {\n        this.connection = connection;\n        this.signature = signature;\n        this._receipt = null;\n    }\n    /**\n     * Gets the transaction receipt, if it has already been fetched.\n     *\n     * You probably want the async version of this function, `wait`.\n     */\n    get receipt() {\n        return this._receipt;\n    }\n    /**\n     * Waits for the confirmation of the transaction, via polling.\n     * @returns\n     */\n    wait(_a = {\n        commitment: \"confirmed\",\n    }) {\n        var { commitment = \"confirmed\" } = _a, retryOpts = (0, tslib_1.__rest)(_a, [\"commitment\"]);\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (this._receipt) {\n                return this._receipt;\n            }\n            const receipt = yield (0, promise_retry_1.default)((retry) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n                const result = yield this.connection.getTransaction(this.signature, {\n                    commitment,\n                });\n                if (!result) {\n                    retry(new Error(\"Error fetching transaction\"));\n                    return;\n                }\n                return new transaction_1.TransactionReceipt(this.signature, result);\n            }), Object.assign({ retries: 5, minTimeout: 500 }, retryOpts));\n            if (!receipt) {\n                throw new Error(\"transaction could not be confirmed\");\n            }\n            this._receipt = receipt;\n            return receipt;\n        });\n    }\n}\nexports.PendingTransaction = PendingTransaction;\n//# sourceMappingURL=PendingTransaction.js.map"]},"metadata":{},"sourceType":"script"}
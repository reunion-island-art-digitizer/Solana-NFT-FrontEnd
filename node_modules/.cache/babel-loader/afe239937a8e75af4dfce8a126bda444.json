{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LedgerError = exports.LedgerWalletAdapter = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst hw_transport_webusb_1 = (0, tslib_1.__importDefault)(require(\"@ledgerhq/hw-transport-webusb\"));\nconst eventemitter3_1 = (0, tslib_1.__importDefault)(require(\"eventemitter3\"));\n\nconst types_1 = require(\"../types\");\n\nconst core_1 = require(\"./core\");\n\nconst DEFAULT_DERIVATION_PATH = (0, core_1.getSolanaDerivationPath)();\n\nclass LedgerWalletAdapter extends eventemitter3_1.default {\n  constructor() {\n    super();\n    this._connecting = false;\n    this._publicKey = null;\n    this._transport = null;\n    this._derivationPath = DEFAULT_DERIVATION_PATH;\n  }\n\n  get publicKey() {\n    return this._publicKey || types_1.DEFAULT_PUBLIC_KEY;\n  }\n\n  get connected() {\n    return this._publicKey !== null;\n  }\n\n  get autoApprove() {\n    return false;\n  }\n\n  signAllTransactions(transactions) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const result = [];\n\n      for (let i = 0; i < transactions.length; i++) {\n        const transaction = transactions[i];\n\n        if (transaction) {\n          const signed = yield this.signTransaction(transaction);\n          result.push(signed);\n        }\n      }\n\n      return result;\n    });\n  }\n\n  signTransaction(transaction) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (!this._transport || !this._publicKey) {\n        throw new Error(\"Not connected to Ledger\");\n      }\n\n      const signature = yield (0, core_1.signTransaction)(this._transport, transaction, this._derivationPath);\n      transaction.addSignature(this._publicKey, signature);\n      return transaction;\n    });\n  }\n\n  connect(args) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (this._connecting) {\n        return;\n      }\n\n      this._connecting = true;\n\n      try {\n        // @TODO: transport selection (WebUSB, WebHID, bluetooth, ...)\n        this._transport = yield hw_transport_webusb_1.default.create();\n\n        if (args) {\n          const {\n            account,\n            change\n          } = args;\n          this._derivationPath = (0, core_1.getSolanaDerivationPath)(account, change);\n          this._publicKey = yield (0, core_1.getPublicKey)(this._transport, this._derivationPath);\n        } else {\n          this._publicKey = yield (0, core_1.getPublicKey)(this._transport);\n        }\n\n        this.emit(\"connect\", this._publicKey);\n      } catch (error) {\n        yield this.disconnect();\n        throw new LedgerError(error);\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n\n  disconnect() {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      let emit = false;\n\n      if (this._transport) {\n        yield this._transport.close();\n        this._transport = null;\n        emit = true;\n      }\n\n      this._connecting = false;\n      this._publicKey = null;\n\n      if (emit) {\n        this.emit(\"disconnect\");\n      }\n    });\n  }\n  /**\n   * Ledger transport.\n   */\n\n\n  get transport() {\n    return this._transport;\n  }\n  /**\n   * Fetches accounts associated with the given derivation paths.\n   *\n   * @param paths\n   * @returns\n   */\n\n\n  static fetchAccountsForPaths(paths) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      let transport = null;\n\n      try {\n        transport = yield hw_transport_webusb_1.default.create();\n        const ret = [];\n\n        for (const path of paths) {\n          const derivationPath = (0, core_1.getSolanaDerivationPath)(path.account, path.change);\n          ret.push(Object.assign(Object.assign({}, path), {\n            key: yield (0, core_1.getPublicKey)(transport, derivationPath)\n          }));\n        }\n\n        return ret;\n      } catch (error) {\n        throw new LedgerError(error);\n      } finally {\n        yield transport === null || transport === void 0 ? void 0 : transport.close();\n      }\n    });\n  }\n\n}\n\nexports.LedgerWalletAdapter = LedgerWalletAdapter;\n\nclass LedgerError extends Error {\n  constructor(error) {\n    super(`Ledger Error: ${error.message}`);\n    this.name = \"LedgerError\";\n  }\n\n}\n\nexports.LedgerError = LedgerError;","map":{"version":3,"sources":["../../../src/adapters/ledger/index.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LedgerError = exports.LedgerWalletAdapter = void 0;\nconst tslib_1 = require(\"tslib\");\nconst hw_transport_webusb_1 = (0, tslib_1.__importDefault)(require(\"@ledgerhq/hw-transport-webusb\"));\nconst eventemitter3_1 = (0, tslib_1.__importDefault)(require(\"eventemitter3\"));\nconst types_1 = require(\"../types\");\nconst core_1 = require(\"./core\");\nconst DEFAULT_DERIVATION_PATH = (0, core_1.getSolanaDerivationPath)();\nclass LedgerWalletAdapter extends eventemitter3_1.default {\n    constructor() {\n        super();\n        this._connecting = false;\n        this._publicKey = null;\n        this._transport = null;\n        this._derivationPath = DEFAULT_DERIVATION_PATH;\n    }\n    get publicKey() {\n        return this._publicKey || types_1.DEFAULT_PUBLIC_KEY;\n    }\n    get connected() {\n        return this._publicKey !== null;\n    }\n    get autoApprove() {\n        return false;\n    }\n    signAllTransactions(transactions) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const result = [];\n            for (let i = 0; i < transactions.length; i++) {\n                const transaction = transactions[i];\n                if (transaction) {\n                    const signed = yield this.signTransaction(transaction);\n                    result.push(signed);\n                }\n            }\n            return result;\n        });\n    }\n    signTransaction(transaction) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (!this._transport || !this._publicKey) {\n                throw new Error(\"Not connected to Ledger\");\n            }\n            const signature = yield (0, core_1.signTransaction)(this._transport, transaction, this._derivationPath);\n            transaction.addSignature(this._publicKey, signature);\n            return transaction;\n        });\n    }\n    connect(args) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (this._connecting) {\n                return;\n            }\n            this._connecting = true;\n            try {\n                // @TODO: transport selection (WebUSB, WebHID, bluetooth, ...)\n                this._transport = yield hw_transport_webusb_1.default.create();\n                if (args) {\n                    const { account, change } = args;\n                    this._derivationPath = (0, core_1.getSolanaDerivationPath)(account, change);\n                    this._publicKey = yield (0, core_1.getPublicKey)(this._transport, this._derivationPath);\n                }\n                else {\n                    this._publicKey = yield (0, core_1.getPublicKey)(this._transport);\n                }\n                this.emit(\"connect\", this._publicKey);\n            }\n            catch (error) {\n                yield this.disconnect();\n                throw new LedgerError(error);\n            }\n            finally {\n                this._connecting = false;\n            }\n        });\n    }\n    disconnect() {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            let emit = false;\n            if (this._transport) {\n                yield this._transport.close();\n                this._transport = null;\n                emit = true;\n            }\n            this._connecting = false;\n            this._publicKey = null;\n            if (emit) {\n                this.emit(\"disconnect\");\n            }\n        });\n    }\n    /**\n     * Ledger transport.\n     */\n    get transport() {\n        return this._transport;\n    }\n    /**\n     * Fetches accounts associated with the given derivation paths.\n     *\n     * @param paths\n     * @returns\n     */\n    static fetchAccountsForPaths(paths) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            let transport = null;\n            try {\n                transport = yield hw_transport_webusb_1.default.create();\n                const ret = [];\n                for (const path of paths) {\n                    const derivationPath = (0, core_1.getSolanaDerivationPath)(path.account, path.change);\n                    ret.push(Object.assign(Object.assign({}, path), { key: yield (0, core_1.getPublicKey)(transport, derivationPath) }));\n                }\n                return ret;\n            }\n            catch (error) {\n                throw new LedgerError(error);\n            }\n            finally {\n                yield (transport === null || transport === void 0 ? void 0 : transport.close());\n            }\n        });\n    }\n}\nexports.LedgerWalletAdapter = LedgerWalletAdapter;\nclass LedgerError extends Error {\n    constructor(error) {\n        super(`Ledger Error: ${error.message}`);\n        this.name = \"LedgerError\";\n    }\n}\nexports.LedgerError = LedgerError;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}
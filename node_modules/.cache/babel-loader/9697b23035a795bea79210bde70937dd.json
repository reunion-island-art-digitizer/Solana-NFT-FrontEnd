{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createATAInstruction = exports.getOrCreateATAs = exports.getOrCreateATA = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst spl_token_1 = require(\"@solana/spl-token\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst ata_1 = require(\"../ata\");\n/**\n * Gets an associated token account, returning a create instruction if it doesn't exist.\n * @param param0\n * @returns\n */\n\n\nconst getOrCreateATA = ({\n  provider,\n  mint,\n  owner = provider.wallet.publicKey,\n  payer = provider.wallet.publicKey\n}) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n  const address = yield (0, ata_1.getATAAddress)({\n    mint,\n    owner\n  });\n\n  if (yield provider.connection.getAccountInfo(address)) {\n    return {\n      address,\n      instruction: null\n    };\n  } else {\n    return {\n      address,\n      instruction: (0, exports.createATAInstruction)({\n        mint,\n        address,\n        owner,\n        payer\n      })\n    };\n  }\n});\n\nexports.getOrCreateATA = getOrCreateATA;\n/**\n * Gets ATAs and creates them if they don't exist.\n * @param param0\n * @returns\n */\n\nconst getOrCreateATAs = ({\n  provider,\n  mints,\n  owner = provider.wallet.publicKey\n}) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n  const result = yield Promise.all(Object.entries(mints).map(([name, mint]) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    const mintKey = new web3_js_1.PublicKey(mint);\n    const result = yield (0, exports.getOrCreateATA)({\n      provider,\n      mint: mintKey,\n      owner: owner,\n      payer: provider.wallet.publicKey\n    });\n    return {\n      address: result.address,\n      instruction: result.instruction,\n      name,\n      mintKey\n    };\n  })));\n  const deduped = result.reduce((acc, {\n    address,\n    name,\n    instruction\n  }) => {\n    return {\n      accounts: Object.assign(Object.assign({}, acc.accounts), {\n        [name]: address\n      }),\n      createAccountInstructions: Object.assign(Object.assign({}, acc.createAccountInstructions), {\n        [name]: instruction\n      }),\n      instructions: instruction ? Object.assign(Object.assign({}, acc.instructions), {\n        [address.toString()]: instruction\n      }) : acc.instructions\n    };\n  }, {\n    accounts: {},\n    instructions: {},\n    createAccountInstructions: {}\n  });\n  return {\n    accounts: deduped.accounts,\n    createAccountInstructions: deduped.createAccountInstructions,\n    instructions: Object.values(deduped.instructions)\n  };\n});\n\nexports.getOrCreateATAs = getOrCreateATAs;\n/**\n * Instruction for creating an ATA.\n * @returns\n */\n\nconst createATAInstruction = ({\n  address,\n  mint,\n  owner,\n  payer\n}) => spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, address, owner, payer);\n\nexports.createATAInstruction = createATAInstruction;","map":{"version":3,"sources":["../../src/instructions/ata.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createATAInstruction = exports.getOrCreateATAs = exports.getOrCreateATA = void 0;\nconst tslib_1 = require(\"tslib\");\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst ata_1 = require(\"../ata\");\n/**\n * Gets an associated token account, returning a create instruction if it doesn't exist.\n * @param param0\n * @returns\n */\nconst getOrCreateATA = ({ provider, mint, owner = provider.wallet.publicKey, payer = provider.wallet.publicKey, }) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    const address = yield (0, ata_1.getATAAddress)({ mint, owner });\n    if (yield provider.connection.getAccountInfo(address)) {\n        return { address, instruction: null };\n    }\n    else {\n        return {\n            address,\n            instruction: (0, exports.createATAInstruction)({\n                mint,\n                address,\n                owner,\n                payer,\n            }),\n        };\n    }\n});\nexports.getOrCreateATA = getOrCreateATA;\n/**\n * Gets ATAs and creates them if they don't exist.\n * @param param0\n * @returns\n */\nconst getOrCreateATAs = ({ provider, mints, owner = provider.wallet.publicKey, }) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n    const result = yield Promise.all(Object.entries(mints).map(([name, mint]) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {\n        const mintKey = new web3_js_1.PublicKey(mint);\n        const result = yield (0, exports.getOrCreateATA)({\n            provider,\n            mint: mintKey,\n            owner: owner,\n            payer: provider.wallet.publicKey,\n        });\n        return {\n            address: result.address,\n            instruction: result.instruction,\n            name,\n            mintKey,\n        };\n    })));\n    const deduped = result.reduce((acc, { address, name, instruction }) => {\n        return {\n            accounts: Object.assign(Object.assign({}, acc.accounts), { [name]: address }),\n            createAccountInstructions: Object.assign(Object.assign({}, acc.createAccountInstructions), { [name]: instruction }),\n            instructions: instruction\n                ? Object.assign(Object.assign({}, acc.instructions), { [address.toString()]: instruction }) : acc.instructions,\n        };\n    }, { accounts: {}, instructions: {}, createAccountInstructions: {} });\n    return {\n        accounts: deduped.accounts,\n        createAccountInstructions: deduped.createAccountInstructions,\n        instructions: Object.values(deduped.instructions),\n    };\n});\nexports.getOrCreateATAs = getOrCreateATAs;\n/**\n * Instruction for creating an ATA.\n * @returns\n */\nconst createATAInstruction = ({ address, mint, owner, payer, }) => spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, mint, address, owner, payer);\nexports.createATAInstruction = createATAInstruction;\n//# sourceMappingURL=ata.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SingleConnectionBroadcaster = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst _1 = require(\".\");\n/**\n * Broadcasts transactions to a single connection.\n */\n\n\nclass SingleConnectionBroadcaster {\n  constructor(sendConnection, opts = _1.DEFAULT_PROVIDER_OPTIONS) {\n    this.sendConnection = sendConnection;\n    this.opts = opts;\n  }\n\n  getRecentBlockhash(commitment = \"recent\") {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const result = yield this.sendConnection.getRecentBlockhash(commitment);\n      return result.blockhash;\n    });\n  }\n  /**\n   * Broadcasts a signed transaction.\n   *\n   * @param tx\n   * @param confirm\n   * @param opts\n   * @returns\n   */\n\n\n  broadcast(tx, opts = this.opts) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (tx.signatures.length === 0) {\n        throw new Error(\"Transaction must be signed before broadcasting.\");\n      }\n\n      const rawTx = tx.serialize();\n      return new _1.PendingTransaction(this.sendConnection, yield this.sendConnection.sendRawTransaction(rawTx, opts));\n    });\n  }\n\n  simulate(tx, commitment = \"recent\") {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      if (tx.signatures.length === 0) {\n        throw new Error(\"Transaction must be signed before simulating.\");\n      }\n\n      return yield (0, _1.simulateTransactionWithCommitment)(this.sendConnection, tx, commitment);\n    });\n  }\n\n}\n\nexports.SingleConnectionBroadcaster = SingleConnectionBroadcaster;","map":{"version":3,"sources":["../src/broadcaster.ts"],"names":[],"mappings":";;;;;;;;;AAWA,MAAA,EAAA,GAAA,OAAA,CAAA,GAAA,CAAA;AAMA;;AAEG;;;AACH,MAAa,2BAAb,CAAwC;AACtC,EAAA,WAAA,CACkB,cADlB,EAEkB,IAAA,GAAuB,EAAA,CAAA,wBAFzC,EAEiE;AAD/C,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,IAAA,GAAA,IAAA;AACd;;AAEE,EAAA,kBAAkB,CACtB,UAAA,GAAyB,QADH,EACW;;AAEjC,YAAM,MAAM,GAAG,MAAM,KAAK,cAAL,CAAoB,kBAApB,CAAuC,UAAvC,CAArB;AACA,aAAO,MAAM,CAAC,SAAd;AACD,K;AAAA;AAED;;;;;;;AAOG;;;AACG,EAAA,SAAS,CACb,EADa,EAEb,IAAA,GAAuB,KAAK,IAFf,EAEmB;;AAEhC,UAAI,EAAE,CAAC,UAAH,CAAc,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,cAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AACD;;AACD,YAAM,KAAK,GAAG,EAAE,CAAC,SAAH,EAAd;AACA,aAAO,IAAI,EAAA,CAAA,kBAAJ,CACL,KAAK,cADA,EAEL,MAAM,KAAK,cAAL,CAAoB,kBAApB,CAAuC,KAAvC,EAA8C,IAA9C,CAFD,CAAP;AAID,K;AAAA;;AAEK,EAAA,QAAQ,CACZ,EADY,EAEZ,UAAA,GAAyB,QAFb,EAEqB;;AAEjC,UAAI,EAAE,CAAC,UAAH,CAAc,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,cAAM,IAAI,KAAJ,CAAU,+CAAV,CAAN;AACD;;AACD,aAAO,MAAM,CAAA,GAAA,EAAA,CAAA,iCAAA,EACX,KAAK,cADM,EAEX,EAFW,EAGX,UAHW,CAAb;AAKD,K;AAAA;;AA/CqC;;AAAxC,OAAA,CAAA,2BAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SingleConnectionBroadcaster = void 0;\nconst tslib_1 = require(\"tslib\");\nconst _1 = require(\".\");\n/**\n * Broadcasts transactions to a single connection.\n */\nclass SingleConnectionBroadcaster {\n    constructor(sendConnection, opts = _1.DEFAULT_PROVIDER_OPTIONS) {\n        this.sendConnection = sendConnection;\n        this.opts = opts;\n    }\n    getRecentBlockhash(commitment = \"recent\") {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const result = yield this.sendConnection.getRecentBlockhash(commitment);\n            return result.blockhash;\n        });\n    }\n    /**\n     * Broadcasts a signed transaction.\n     *\n     * @param tx\n     * @param confirm\n     * @param opts\n     * @returns\n     */\n    broadcast(tx, opts = this.opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (tx.signatures.length === 0) {\n                throw new Error(\"Transaction must be signed before broadcasting.\");\n            }\n            const rawTx = tx.serialize();\n            return new _1.PendingTransaction(this.sendConnection, yield this.sendConnection.sendRawTransaction(rawTx, opts));\n        });\n    }\n    simulate(tx, commitment = \"recent\") {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            if (tx.signatures.length === 0) {\n                throw new Error(\"Transaction must be signed before simulating.\");\n            }\n            return yield (0, _1.simulateTransactionWithCommitment)(this.sendConnection, tx, commitment);\n        });\n    }\n}\nexports.SingleConnectionBroadcaster = SingleConnectionBroadcaster;\n//# sourceMappingURL=broadcaster.js.map"]},"metadata":{},"sourceType":"script"}
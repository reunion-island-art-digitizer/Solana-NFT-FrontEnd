{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionEnvelope = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * Contains a Transaction that is being built.\n */\n\n\nclass TransactionEnvelope {\n  constructor(provider, instructions, signers = []) {\n    this.provider = provider;\n    this.instructions = instructions;\n    this.signers = signers;\n  }\n\n  addSigners(...signers) {\n    this.signers.push(...signers);\n    return this;\n  }\n  /**\n   * Builds a transaction from this envelope.\n   */\n\n\n  build() {\n    return new web3_js_1.Transaction().add(...this.instructions);\n  }\n  /**\n   * Generates a link for inspecting the contents of this {@link TransactionEnvelope}.\n   *\n   * @returns URL\n   */\n\n\n  generateInspectLink(cluster = \"mainnet-beta\") {\n    const t = this.build();\n    t.recentBlockhash = \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"; // Some stub\n\n    t.feePayer = this.provider.wallet.publicKey;\n    const str = t.serializeMessage().toString(\"base64\");\n    return `https://explorer.solana.com/tx/inspector?cluster=${cluster}&message=${encodeURIComponent(str)}`;\n  }\n  /**\n   * Simulates the transaction.\n   * @param opts\n   * @returns\n   */\n\n\n  simulate(opts) {\n    return this.provider.simulate(this.build(), this.signers, opts);\n  }\n  /**\n   * Sends the transaction without confirming it.\n   * @param opts\n   * @returns\n   */\n\n\n  send(opts) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const signed = yield this.provider.signer.sign(this.build(), this.signers, opts);\n      return this.provider.broadcaster.broadcast(signed, opts);\n    });\n  }\n  /**\n   * Sends the transaction and waits for confirmation.\n   * @param opts\n   */\n\n\n  confirm(opts) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      return (yield this.send(opts)).wait();\n    });\n  }\n  /**\n   * Combines the instructions/signers of the other envelope to create one large transaction.\n   */\n\n\n  combine(other) {\n    return new TransactionEnvelope(this.provider, [...this.instructions, ...other.instructions], [...this.signers, ...other.signers]);\n  }\n  /**\n   * Get a list of all writable accounts, deduped\n   * All of these accounts likely need to be updated after the transaction is confirmed.\n   */\n\n\n  get writableKeys() {\n    return [...new Set([...this.instructions.map(inst => inst.keys.filter(key => key.isWritable).map(k => k.pubkey)).reduce((acc, el) => acc.concat(el))]).values()];\n  }\n  /**\n   * Gets the instructions in a format that can be serialized easily to JSON.\n   */\n\n\n  get instructionsJSON() {\n    return this.instructions.map(instruction => ({\n      programId: instruction.programId.toString(),\n      keys: instruction.keys.map(m => ({\n        isSigner: m.isSigner,\n        isWritable: m.isWritable,\n        publicKey: m.pubkey.toString()\n      })),\n      data: instruction.data.toString(\"base64\")\n    }));\n  }\n  /**\n   * Returns a string representation of the {@link TransactionEnvelope}.\n   */\n\n\n  get debugStr() {\n    return [\"=> Instructions\", this.instructions.map((ser, i) => {\n      return [`Instruction ${i}: ${ser.programId.toString()}`, ...ser.keys.map((k, i) => `  [${i}] ${k.pubkey.toString()} ${k.isWritable ? \"(mut)\" : \"\"} ${k.isSigner ? \"(signer)\" : \"\"}`), `  Data (base64): ${ser.data.toString(\"base64\")}`].join(\"\\n\");\n    }).join(\"\\n\"), \"=> Signers\", this.signers.map(sg => sg.publicKey.toString()).join(\"\\n\")].join(\"\\n\");\n  }\n  /**\n   * Combines multiple TransactionEnvelopes into one.\n   */\n\n\n  static combineAll(...txs) {\n    return txs.reduce((acc, tx) => acc.combine(tx));\n  }\n  /**\n   * Combines multiple async TransactionEnvelopes into one, serially.\n   */\n\n\n  static combineAllAsync(firstTX, ...txs) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      let acc = yield firstTX;\n\n      for (const tx of txs) {\n        acc = acc.combine(yield tx);\n      }\n\n      return acc;\n    });\n  }\n  /**\n   * Sends all of the envelopes.\n   * @returns Pending transactions\n   */\n\n\n  static sendAll(txs, opts) {\n    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n      const firstTX = txs[0];\n\n      if (!firstTX) {\n        return [];\n      }\n\n      const provider = firstTX.provider;\n      return yield provider.sendAll(txs.map(tx => ({\n        tx: tx.build(),\n        signers: tx.signers\n      })), opts);\n    });\n  }\n\n}\n\nexports.TransactionEnvelope = TransactionEnvelope;","map":{"version":3,"sources":["../../src/transaction/TransactionEnvelope.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionEnvelope = void 0;\nconst tslib_1 = require(\"tslib\");\nconst web3_js_1 = require(\"@solana/web3.js\");\n/**\n * Contains a Transaction that is being built.\n */\nclass TransactionEnvelope {\n    constructor(provider, instructions, signers = []) {\n        this.provider = provider;\n        this.instructions = instructions;\n        this.signers = signers;\n    }\n    addSigners(...signers) {\n        this.signers.push(...signers);\n        return this;\n    }\n    /**\n     * Builds a transaction from this envelope.\n     */\n    build() {\n        return new web3_js_1.Transaction().add(...this.instructions);\n    }\n    /**\n     * Generates a link for inspecting the contents of this {@link TransactionEnvelope}.\n     *\n     * @returns URL\n     */\n    generateInspectLink(cluster = \"mainnet-beta\") {\n        const t = this.build();\n        t.recentBlockhash = \"EETubP5AKHgjPAhzPAFcb8BAY1hMH639CWCFTqi3hq1k\"; // Some stub\n        t.feePayer = this.provider.wallet.publicKey;\n        const str = t.serializeMessage().toString(\"base64\");\n        return `https://explorer.solana.com/tx/inspector?cluster=${cluster}&message=${encodeURIComponent(str)}`;\n    }\n    /**\n     * Simulates the transaction.\n     * @param opts\n     * @returns\n     */\n    simulate(opts) {\n        return this.provider.simulate(this.build(), this.signers, opts);\n    }\n    /**\n     * Sends the transaction without confirming it.\n     * @param opts\n     * @returns\n     */\n    send(opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const signed = yield this.provider.signer.sign(this.build(), this.signers, opts);\n            return this.provider.broadcaster.broadcast(signed, opts);\n        });\n    }\n    /**\n     * Sends the transaction and waits for confirmation.\n     * @param opts\n     */\n    confirm(opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            return (yield this.send(opts)).wait();\n        });\n    }\n    /**\n     * Combines the instructions/signers of the other envelope to create one large transaction.\n     */\n    combine(other) {\n        return new TransactionEnvelope(this.provider, [...this.instructions, ...other.instructions], [...this.signers, ...other.signers]);\n    }\n    /**\n     * Get a list of all writable accounts, deduped\n     * All of these accounts likely need to be updated after the transaction is confirmed.\n     */\n    get writableKeys() {\n        return [\n            ...new Set([\n                ...this.instructions\n                    .map((inst) => inst.keys.filter((key) => key.isWritable).map((k) => k.pubkey))\n                    .reduce((acc, el) => acc.concat(el)),\n            ]).values(),\n        ];\n    }\n    /**\n     * Gets the instructions in a format that can be serialized easily to JSON.\n     */\n    get instructionsJSON() {\n        return this.instructions.map((instruction) => ({\n            programId: instruction.programId.toString(),\n            keys: instruction.keys.map((m) => ({\n                isSigner: m.isSigner,\n                isWritable: m.isWritable,\n                publicKey: m.pubkey.toString(),\n            })),\n            data: instruction.data.toString(\"base64\"),\n        }));\n    }\n    /**\n     * Returns a string representation of the {@link TransactionEnvelope}.\n     */\n    get debugStr() {\n        return [\n            \"=> Instructions\",\n            this.instructions\n                .map((ser, i) => {\n                return [\n                    `Instruction ${i}: ${ser.programId.toString()}`,\n                    ...ser.keys.map((k, i) => `  [${i}] ${k.pubkey.toString()} ${k.isWritable ? \"(mut)\" : \"\"} ${k.isSigner ? \"(signer)\" : \"\"}`),\n                    `  Data (base64): ${ser.data.toString(\"base64\")}`,\n                ].join(\"\\n\");\n            })\n                .join(\"\\n\"),\n            \"=> Signers\",\n            this.signers.map((sg) => sg.publicKey.toString()).join(\"\\n\"),\n        ].join(\"\\n\");\n    }\n    /**\n     * Combines multiple TransactionEnvelopes into one.\n     */\n    static combineAll(...txs) {\n        return txs.reduce((acc, tx) => acc.combine(tx));\n    }\n    /**\n     * Combines multiple async TransactionEnvelopes into one, serially.\n     */\n    static combineAllAsync(firstTX, ...txs) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            let acc = yield firstTX;\n            for (const tx of txs) {\n                acc = acc.combine(yield tx);\n            }\n            return acc;\n        });\n    }\n    /**\n     * Sends all of the envelopes.\n     * @returns Pending transactions\n     */\n    static sendAll(txs, opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const firstTX = txs[0];\n            if (!firstTX) {\n                return [];\n            }\n            const provider = firstTX.provider;\n            return yield provider.sendAll(txs.map((tx) => ({ tx: tx.build(), signers: tx.signers })), opts);\n        });\n    }\n}\nexports.TransactionEnvelope = TransactionEnvelope;\n//# sourceMappingURL=TransactionEnvelope.js.map"]},"metadata":{},"sourceType":"script"}
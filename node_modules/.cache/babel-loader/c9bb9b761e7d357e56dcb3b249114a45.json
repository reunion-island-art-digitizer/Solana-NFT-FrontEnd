{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _regeneratorRuntime = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/piroi16/Documents/GitHub/Solana-NFT-FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SolanaProvider = exports.SolanaTransactionSigner = exports.SolanaReadonlyProvider = exports.DEFAULT_PROVIDER_OPTIONS = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar broadcaster_1 = require(\"./broadcaster\");\n\nexports.DEFAULT_PROVIDER_OPTIONS = {\n  preflightCommitment: \"recent\",\n  commitment: \"recent\"\n};\n/**\n * Provider that can only read.\n */\n\nvar SolanaReadonlyProvider = /*#__PURE__*/function () {\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param sendConnection The connection where transactions are sent to.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  function SolanaReadonlyProvider(connection) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.DEFAULT_PROVIDER_OPTIONS;\n\n    _classCallCheck(this, SolanaReadonlyProvider);\n\n    this.connection = connection;\n    this.opts = opts;\n  }\n  /**\n   * Gets\n   * @param accountId\n   * @returns\n   */\n\n\n  _createClass(SolanaReadonlyProvider, [{\n    key: \"getAccountInfo\",\n    value: function getAccountInfo(accountId) {\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var accountInfo;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.connection.getAccountInfo(accountId, this.opts.commitment);\n\n              case 2:\n                accountInfo = _context.sent;\n\n                if (accountInfo) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 5:\n                return _context.abrupt(\"return\", {\n                  accountId: accountId,\n                  accountInfo: accountInfo\n                });\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return SolanaReadonlyProvider;\n}();\n\nexports.SolanaReadonlyProvider = SolanaReadonlyProvider;\n/**\n * Signs Solana transactions.\n */\n\nvar SolanaTransactionSigner = /*#__PURE__*/function () {\n  function SolanaTransactionSigner(wallet, broadcaster) {\n    var preflightCommitment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"recent\";\n\n    _classCallCheck(this, SolanaTransactionSigner);\n\n    this.wallet = wallet;\n    this.broadcaster = broadcaster;\n    this.preflightCommitment = preflightCommitment;\n  }\n\n  _createClass(SolanaTransactionSigner, [{\n    key: \"publicKey\",\n    get: function get() {\n      return this.wallet.publicKey;\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(tx) {\n      var signers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        preflightCommitment: this.preflightCommitment\n      };\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                tx.feePayer = this.wallet.publicKey;\n                _context2.next = 3;\n                return this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n\n              case 3:\n                tx.recentBlockhash = _context2.sent;\n                _context2.next = 6;\n                return this.wallet.signTransaction(tx);\n\n              case 6:\n                signers.filter(function (s) {\n                  return s !== undefined;\n                }).forEach(function (kp) {\n                  tx.partialSign(kp);\n                });\n                return _context2.abrupt(\"return\", tx);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n\n  }, {\n    key: \"signAll\",\n    value: function signAll(reqs) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        preflightCommitment: this.preflightCommitment\n      };\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this = this;\n\n        var blockhash, txs, signedTxs;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n\n              case 2:\n                blockhash = _context3.sent;\n                txs = reqs.map(function (r) {\n                  var tx = r.tx;\n                  var signers = r.signers;\n\n                  if (signers === undefined) {\n                    signers = [];\n                  }\n\n                  tx.feePayer = _this.wallet.publicKey;\n                  tx.recentBlockhash = blockhash;\n                  signers.filter(function (s) {\n                    return s !== undefined;\n                  }).forEach(function (kp) {\n                    tx.partialSign(kp);\n                  });\n                  return tx;\n                });\n                _context3.next = 6;\n                return this.wallet.signAllTransactions(txs);\n\n              case 6:\n                signedTxs = _context3.sent;\n                return _context3.abrupt(\"return\", signedTxs);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }]);\n\n  return SolanaTransactionSigner;\n}();\n\nexports.SolanaTransactionSigner = SolanaTransactionSigner;\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n *\n * This implementation was taken from Anchor.\n */\n\nvar SolanaProvider = /*#__PURE__*/function (_SolanaReadonlyProvid) {\n  _inherits(SolanaProvider, _SolanaReadonlyProvid);\n\n  var _super = _createSuper(SolanaProvider);\n\n  /**\n   * @param connection The cluster connection where the program is deployed.\n   * @param sendConnection The connection where transactions are sent to.\n   * @param wallet     The wallet used to pay for and sign all transactions.\n   * @param opts       Transaction confirmation options to use by default.\n   */\n  function SolanaProvider(connection, broadcaster, wallet) {\n    var _this2;\n\n    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.DEFAULT_PROVIDER_OPTIONS;\n\n    _classCallCheck(this, SolanaProvider);\n\n    _this2 = _super.call(this, connection, opts);\n    _this2.connection = connection;\n    _this2.broadcaster = broadcaster;\n    _this2.wallet = wallet;\n    _this2.opts = opts;\n    _this2.signer = new SolanaTransactionSigner(wallet, broadcaster, opts.preflightCommitment);\n    return _this2;\n  }\n  /**\n   * Creates a new SolanaProvider.\n   */\n\n\n  _createClass(SolanaProvider, [{\n    key: \"send\",\n    value:\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    function send(tx) {\n      var signers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts;\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var theTx, pending;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.signer.sign(tx, signers, opts);\n\n              case 2:\n                theTx = _context4.sent;\n                _context4.next = 5;\n                return this.broadcaster.broadcast(theTx, opts);\n\n              case 5:\n                pending = _context4.sent;\n                _context4.next = 8;\n                return pending.wait();\n\n              case 8:\n                return _context4.abrupt(\"return\", pending);\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n\n  }, {\n    key: \"sendAll\",\n    value: function sendAll(reqs) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.opts;\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this3 = this;\n\n        var txs;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.signer.signAll(reqs, opts);\n\n              case 2:\n                txs = _context6.sent;\n                _context6.next = 5;\n                return Promise.all(txs.map(function (tx) {\n                  return (0, tslib_1.__awaiter)(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                    var pending;\n                    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return this.broadcaster.broadcast(tx, opts);\n\n                          case 2:\n                            pending = _context5.sent;\n                            _context5.next = 5;\n                            return pending.wait();\n\n                          case 5:\n                            return _context5.abrupt(\"return\", pending);\n\n                          case 6:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5, this);\n                  }));\n                }));\n\n              case 5:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n\n  }, {\n    key: \"simulate\",\n    value: function simulate(tx) {\n      var signers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts;\n      return (0, tslib_1.__awaiter)(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var signedTx;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.signer.sign(tx, signers, opts);\n\n              case 2:\n                signedTx = _context7.sent;\n                _context7.next = 5;\n                return this.broadcaster.simulate(signedTx, opts.commitment);\n\n              case 5:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }], [{\n    key: \"load\",\n    value: function load(_ref) {\n      var connection = _ref.connection,\n          _ref$sendConnection = _ref.sendConnection,\n          sendConnection = _ref$sendConnection === void 0 ? connection : _ref$sendConnection,\n          wallet = _ref.wallet,\n          opts = _ref.opts;\n      return new SolanaProvider(connection, new broadcaster_1.SingleConnectionBroadcaster(sendConnection, opts), wallet, opts);\n    }\n  }]);\n\n  return SolanaProvider;\n}(SolanaReadonlyProvider);\n\nexports.SolanaProvider = SolanaProvider;","map":{"version":3,"sources":["../src/provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SolanaProvider = exports.SolanaTransactionSigner = exports.SolanaReadonlyProvider = exports.DEFAULT_PROVIDER_OPTIONS = void 0;\nconst tslib_1 = require(\"tslib\");\nconst broadcaster_1 = require(\"./broadcaster\");\nexports.DEFAULT_PROVIDER_OPTIONS = {\n    preflightCommitment: \"recent\",\n    commitment: \"recent\",\n};\n/**\n * Provider that can only read.\n */\nclass SolanaReadonlyProvider {\n    /**\n     * @param connection The cluster connection where the program is deployed.\n     * @param sendConnection The connection where transactions are sent to.\n     * @param wallet     The wallet used to pay for and sign all transactions.\n     * @param opts       Transaction confirmation options to use by default.\n     */\n    constructor(connection, opts = exports.DEFAULT_PROVIDER_OPTIONS) {\n        this.connection = connection;\n        this.opts = opts;\n    }\n    /**\n     * Gets\n     * @param accountId\n     * @returns\n     */\n    getAccountInfo(accountId) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const accountInfo = yield this.connection.getAccountInfo(accountId, this.opts.commitment);\n            if (!accountInfo) {\n                return null;\n            }\n            return {\n                accountId,\n                accountInfo,\n            };\n        });\n    }\n}\nexports.SolanaReadonlyProvider = SolanaReadonlyProvider;\n/**\n * Signs Solana transactions.\n */\nclass SolanaTransactionSigner {\n    constructor(wallet, broadcaster, preflightCommitment = \"recent\") {\n        this.wallet = wallet;\n        this.broadcaster = broadcaster;\n        this.preflightCommitment = preflightCommitment;\n    }\n    get publicKey() {\n        return this.wallet.publicKey;\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    sign(tx, signers = [], opts = {\n        preflightCommitment: this.preflightCommitment,\n    }) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            tx.feePayer = this.wallet.publicKey;\n            tx.recentBlockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n            yield this.wallet.signTransaction(tx);\n            signers\n                .filter((s) => s !== undefined)\n                .forEach((kp) => {\n                tx.partialSign(kp);\n            });\n            return tx;\n        });\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n    signAll(reqs, opts = {\n        preflightCommitment: this.preflightCommitment,\n    }) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const blockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);\n            const txs = reqs.map((r) => {\n                const tx = r.tx;\n                let signers = r.signers;\n                if (signers === undefined) {\n                    signers = [];\n                }\n                tx.feePayer = this.wallet.publicKey;\n                tx.recentBlockhash = blockhash;\n                signers\n                    .filter((s) => s !== undefined)\n                    .forEach((kp) => {\n                    tx.partialSign(kp);\n                });\n                return tx;\n            });\n            const signedTxs = yield this.wallet.signAllTransactions(txs);\n            return signedTxs;\n        });\n    }\n}\nexports.SolanaTransactionSigner = SolanaTransactionSigner;\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n *\n * This implementation was taken from Anchor.\n */\nclass SolanaProvider extends SolanaReadonlyProvider {\n    /**\n     * @param connection The cluster connection where the program is deployed.\n     * @param sendConnection The connection where transactions are sent to.\n     * @param wallet     The wallet used to pay for and sign all transactions.\n     * @param opts       Transaction confirmation options to use by default.\n     */\n    constructor(connection, broadcaster, wallet, opts = exports.DEFAULT_PROVIDER_OPTIONS) {\n        super(connection, opts);\n        this.connection = connection;\n        this.broadcaster = broadcaster;\n        this.wallet = wallet;\n        this.opts = opts;\n        this.signer = new SolanaTransactionSigner(wallet, broadcaster, opts.preflightCommitment);\n    }\n    /**\n     * Creates a new SolanaProvider.\n     */\n    static load({ connection, sendConnection = connection, wallet, opts, }) {\n        return new SolanaProvider(connection, new broadcaster_1.SingleConnectionBroadcaster(sendConnection, opts), wallet, opts);\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    send(tx, signers = [], opts = this.opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const theTx = yield this.signer.sign(tx, signers, opts);\n            const pending = yield this.broadcaster.broadcast(theTx, opts);\n            yield pending.wait();\n            return pending;\n        });\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     */\n    sendAll(reqs, opts = this.opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const txs = yield this.signer.signAll(reqs, opts);\n            return yield Promise.all(txs.map((tx) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n                const pending = yield this.broadcaster.broadcast(tx, opts);\n                yield pending.wait();\n                return pending;\n            })));\n        });\n    }\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The set of signers in addition to the provdier wallet that\n     *                will sign the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    simulate(tx, signers = [], opts = this.opts) {\n        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {\n            const signedTx = yield this.signer.sign(tx, signers, opts);\n            return yield this.broadcaster.simulate(signedTx, opts.commitment);\n        });\n    }\n}\nexports.SolanaProvider = SolanaProvider;\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"script"}
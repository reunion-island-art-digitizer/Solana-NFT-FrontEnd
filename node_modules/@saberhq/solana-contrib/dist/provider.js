"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaProvider = exports.SolanaTransactionSigner = exports.SolanaReadonlyProvider = exports.DEFAULT_PROVIDER_OPTIONS = void 0;
const tslib_1 = require("tslib");
const broadcaster_1 = require("./broadcaster");
exports.DEFAULT_PROVIDER_OPTIONS = {
    preflightCommitment: "recent",
    commitment: "recent",
};
/**
 * Provider that can only read.
 */
class SolanaReadonlyProvider {
    /**
     * @param connection The cluster connection where the program is deployed.
     * @param sendConnection The connection where transactions are sent to.
     * @param wallet     The wallet used to pay for and sign all transactions.
     * @param opts       Transaction confirmation options to use by default.
     */
    constructor(connection, opts = exports.DEFAULT_PROVIDER_OPTIONS) {
        this.connection = connection;
        this.opts = opts;
    }
    /**
     * Gets
     * @param accountId
     * @returns
     */
    getAccountInfo(accountId) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const accountInfo = yield this.connection.getAccountInfo(accountId, this.opts.commitment);
            if (!accountInfo) {
                return null;
            }
            return {
                accountId,
                accountInfo,
            };
        });
    }
}
exports.SolanaReadonlyProvider = SolanaReadonlyProvider;
/**
 * Signs Solana transactions.
 */
class SolanaTransactionSigner {
    constructor(wallet, broadcaster, preflightCommitment = "recent") {
        this.wallet = wallet;
        this.broadcaster = broadcaster;
        this.preflightCommitment = preflightCommitment;
    }
    get publicKey() {
        return this.wallet.publicKey;
    }
    /**
     * Sends the given transaction, paid for and signed by the provider's wallet.
     *
     * @param tx      The transaction to send.
     * @param signers The set of signers in addition to the provdier wallet that
     *                will sign the transaction.
     * @param opts    Transaction confirmation options.
     */
    sign(tx, signers = [], opts = {
        preflightCommitment: this.preflightCommitment,
    }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            tx.feePayer = this.wallet.publicKey;
            tx.recentBlockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);
            yield this.wallet.signTransaction(tx);
            signers
                .filter((s) => s !== undefined)
                .forEach((kp) => {
                tx.partialSign(kp);
            });
            return tx;
        });
    }
    /**
     * Similar to `send`, but for an array of transactions and signers.
     */
    signAll(reqs, opts = {
        preflightCommitment: this.preflightCommitment,
    }) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const blockhash = yield this.broadcaster.getRecentBlockhash(opts.preflightCommitment);
            const txs = reqs.map((r) => {
                const tx = r.tx;
                let signers = r.signers;
                if (signers === undefined) {
                    signers = [];
                }
                tx.feePayer = this.wallet.publicKey;
                tx.recentBlockhash = blockhash;
                signers
                    .filter((s) => s !== undefined)
                    .forEach((kp) => {
                    tx.partialSign(kp);
                });
                return tx;
            });
            const signedTxs = yield this.wallet.signAllTransactions(txs);
            return signedTxs;
        });
    }
}
exports.SolanaTransactionSigner = SolanaTransactionSigner;
/**
 * The network and wallet context used to send transactions paid for and signed
 * by the provider.
 *
 * This implementation was taken from Anchor.
 */
class SolanaProvider extends SolanaReadonlyProvider {
    /**
     * @param connection The cluster connection where the program is deployed.
     * @param sendConnection The connection where transactions are sent to.
     * @param wallet     The wallet used to pay for and sign all transactions.
     * @param opts       Transaction confirmation options to use by default.
     */
    constructor(connection, broadcaster, wallet, opts = exports.DEFAULT_PROVIDER_OPTIONS) {
        super(connection, opts);
        this.connection = connection;
        this.broadcaster = broadcaster;
        this.wallet = wallet;
        this.opts = opts;
        this.signer = new SolanaTransactionSigner(wallet, broadcaster, opts.preflightCommitment);
    }
    /**
     * Creates a new SolanaProvider.
     */
    static load({ connection, sendConnection = connection, wallet, opts, }) {
        return new SolanaProvider(connection, new broadcaster_1.SingleConnectionBroadcaster(sendConnection, opts), wallet, opts);
    }
    /**
     * Sends the given transaction, paid for and signed by the provider's wallet.
     *
     * @param tx      The transaction to send.
     * @param signers The set of signers in addition to the provdier wallet that
     *                will sign the transaction.
     * @param opts    Transaction confirmation options.
     */
    send(tx, signers = [], opts = this.opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const theTx = yield this.signer.sign(tx, signers, opts);
            const pending = yield this.broadcaster.broadcast(theTx, opts);
            yield pending.wait();
            return pending;
        });
    }
    /**
     * Similar to `send`, but for an array of transactions and signers.
     */
    sendAll(reqs, opts = this.opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const txs = yield this.signer.signAll(reqs, opts);
            return yield Promise.all(txs.map((tx) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const pending = yield this.broadcaster.broadcast(tx, opts);
                yield pending.wait();
                return pending;
            })));
        });
    }
    /**
     * Simulates the given transaction, returning emitted logs from execution.
     *
     * @param tx      The transaction to send.
     * @param signers The set of signers in addition to the provdier wallet that
     *                will sign the transaction.
     * @param opts    Transaction confirmation options.
     */
    simulate(tx, signers = [], opts = this.opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const signedTx = yield this.signer.sign(tx, signers, opts);
            return yield this.broadcaster.simulate(signedTx, opts.commitment);
        });
    }
}
exports.SolanaProvider = SolanaProvider;
//# sourceMappingURL=provider.js.map
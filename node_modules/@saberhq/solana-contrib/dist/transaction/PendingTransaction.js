"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingTransaction = void 0;
const tslib_1 = require("tslib");
const promise_retry_1 = (0, tslib_1.__importDefault)(require("promise-retry"));
const transaction_1 = require("../transaction");
/**
 * Transaction which may or may not be confirmed.
 */
class PendingTransaction {
    constructor(connection, signature) {
        this.connection = connection;
        this.signature = signature;
        this._receipt = null;
    }
    /**
     * Gets the transaction receipt, if it has already been fetched.
     *
     * You probably want the async version of this function, `wait`.
     */
    get receipt() {
        return this._receipt;
    }
    /**
     * Waits for the confirmation of the transaction, via polling.
     * @returns
     */
    wait(_a = {
        commitment: "confirmed",
    }) {
        var { commitment = "confirmed" } = _a, retryOpts = (0, tslib_1.__rest)(_a, ["commitment"]);
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (this._receipt) {
                return this._receipt;
            }
            const receipt = yield (0, promise_retry_1.default)((retry) => (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
                const result = yield this.connection.getTransaction(this.signature, {
                    commitment,
                });
                if (!result) {
                    retry(new Error("Error fetching transaction"));
                    return;
                }
                return new transaction_1.TransactionReceipt(this.signature, result);
            }), Object.assign({ retries: 5, minTimeout: 500 }, retryOpts));
            if (!receipt) {
                throw new Error("transaction could not be confirmed");
            }
            this._receipt = receipt;
            return receipt;
        });
    }
}
exports.PendingTransaction = PendingTransaction;
//# sourceMappingURL=PendingTransaction.js.map
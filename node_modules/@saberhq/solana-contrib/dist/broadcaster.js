"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleConnectionBroadcaster = void 0;
const tslib_1 = require("tslib");
const _1 = require(".");
/**
 * Broadcasts transactions to a single connection.
 */
class SingleConnectionBroadcaster {
    constructor(sendConnection, opts = _1.DEFAULT_PROVIDER_OPTIONS) {
        this.sendConnection = sendConnection;
        this.opts = opts;
    }
    getRecentBlockhash(commitment = "recent") {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const result = yield this.sendConnection.getRecentBlockhash(commitment);
            return result.blockhash;
        });
    }
    /**
     * Broadcasts a signed transaction.
     *
     * @param tx
     * @param confirm
     * @param opts
     * @returns
     */
    broadcast(tx, opts = this.opts) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (tx.signatures.length === 0) {
                throw new Error("Transaction must be signed before broadcasting.");
            }
            const rawTx = tx.serialize();
            return new _1.PendingTransaction(this.sendConnection, yield this.sendConnection.sendRawTransaction(rawTx, opts));
        });
    }
    simulate(tx, commitment = "recent") {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (tx.signatures.length === 0) {
                throw new Error("Transaction must be signed before simulating.");
            }
            return yield (0, _1.simulateTransactionWithCommitment)(this.sendConnection, tx, commitment);
        });
    }
}
exports.SingleConnectionBroadcaster = SingleConnectionBroadcaster;
//# sourceMappingURL=broadcaster.js.map